<html>
	<head>
		<title>My first three.js app</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; }
			canvas{
				width: 100%;
				height: 100%;
				position: absolute;
			}
			canvas#myCanvas {
				z-index: -1;
				left: 0; top: 0;
			}
			canvas#aim {
				z-index: 10;
				left: 0; top: 0;
			}
			canvas#minimap{
				z-index: 20;
				left: 0; top: 0;
			}
		</style>
	</head>
	<body>
		<canvas id="myCanvas"></canvas>
		<canvas id="aim"></canvas>
		<canvas id="minimap"></canvas>
		<script src="js/three.js"></script>
		<script src="js/webvr.js"></script>
		<script>
			var loader = new THREE.TextureLoader();
			var texture = loader.load( "assets/UV_Grid_Sm.jpg" );
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set( 0.008, 0.008 );
			
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 105, window.innerWidth/window.innerHeight, 0.001, 1000 );

			var cvs = document.getElementById('myCanvas');
			var renderer = new THREE.WebGLRenderer({canvas: cvs});
			renderer.domElement.id = 'myCanvas';
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor(0xaaccff);
			var y_val = 1;
			var gravity = 9.8;
			var Bottom, Sphere;
			var coor = {x: 0, y: y_val, z: 0, deg: 0, ydeg: 0, frame: 0, v_x: 0, v_z: 0};
			var moving = {doing: false, ori_x: 0, ori_y: 0, ori_deg: 0};
			var press = {left: false, right: false, up: false, down: false};
			var moveScale = {move: 6, deg: 2};
			var cursor_now = {x: 0, y: 0};
			var jump = {jumping: false, time: 0};
			var prev_time = 0;
			var save_view = [];
			var row, col;
			var max_frame = 3000;
			var finished = false;
			/*var maze = [[1, 1, 1, 1, 1, 1, 1],
						[1, 0, 0, 0, 1, 0, 0],
						[1, 0, 1, 0, 1, 0, 1], 
						[1, 0, 1, 0, 1, 0, 1], 
						[1, 0, 1, 0, 0, 0, 1], 
						[1, 0, 1, 0, 1, 0, 1], 
						[1, 2, 1, 0, 0, 0, 1], 
						[1, 1, 1, 1, 1, 1, 1]];*/
			var maze = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
						[1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
						[1, 0, 1, 0, 1, 0, 1, 0, 1, 1],
						[1, 0, 1, 0, 1, 0, 0, 0, 1, 1],
						[1, 2, 0, 0, 1, 0, 1, 0, 1, 1],
						[1, 0, 1, 1, 1, 1, 1, 0, 0, 1],
						[1, 0, 1, 0, 0, 1, 0, 0, 1, 1],
						[1, 0, 0, 0, 1, 1, 0, 1, 1, 1],
						[1, 0, 1, 0, 0, 1, 0, 0, 0, 0],
						[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]];
			var show_minimap = false;

			var ctx, ctxmap;
			window.onload = init;
			
			function init(){
				/*
				WEBVR.checkAvailability().catch( function( message ) {
					document.body.appendChild( WEBVR.getMessageContainer( message ) );
				} );
				*/
				document.body.appendChild( renderer.domElement );
				/*
				renderer.vr.enabled = true;
				WEBVR.getVRDisplay( function ( display ) {
					renderer.vr.setDevice( display );
					document.body.appendChild( WEBVR.getButton( display, renderer.domElement ) );
				} );
				*/
				window.addEventListener( 'resize', onWindowResize, false );
				window.addEventListener( 'keyup', onKeyUp, true);
				window.addEventListener( 'keydown', onKeyDown, true);
				window.addEventListener( 'mousemove', onMouseMove, true);
				window.addEventListener( 'mousedown', onMouseDown, true);
				
				var drawBottom = function(){
					var sqPts = [];
					row = maze.length;
					col = maze[0].length;
					sqPts.push(new THREE.Vector2(-col * 5, -row * 5));
					sqPts.push(new THREE.Vector2(col * 5, -row * 5));
					sqPts.push(new THREE.Vector2(col * 5, row * 5));
					sqPts.push(new THREE.Vector2(-col * 5, row * 5));
					sqPts.push(new THREE.Vector2(-col * 5, -row * 5));
					var square = new THREE.Shape(sqPts);
					var Bottom = new THREE.Mesh(new THREE.ShapeBufferGeometry(square), new THREE.MeshBasicMaterial( {map: texture} ));
					Bottom.position.set(0, 0, 0);
					Bottom.rotation.x = -Math.PI/2;
					scene.add(Bottom);

					var geometry = new THREE.SphereGeometry( 0.007, 32, 32 );
					var material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
					Sphere = new THREE.Mesh( geometry, material );
					//scene.add( Sphere );
					var material = new THREE.SpriteMaterial( { color: 0x000000 } );
					/*
					sprite1 = new THREE.Sprite(material);
					sprite1.scale.set(0.05,0.0028,1);
					sprite2 = new THREE.Sprite(material);
					sprite2.scale.set(0.006,0.05,1);
					scene.add(sprite1); scene.add(sprite2);
					*/
				}
				var makemaze = function(){
					wall = new Array(row);
					for(var i=0;i<row;i++){
						wall[i] = new Array(col);
						for(var j=0;j<col;j++){
							if(maze[i][j] == 1){
								var wall_geometry = new THREE.BoxGeometry( 5, 10, 5 );
								var material = new THREE.MeshNormalMaterial( {color: 0xff00ff} );
								wall[i][j] = new THREE.Mesh(wall_geometry, material);
								wall[i][j].position.set(j * 5, 5, i * 5);
								scene.add(wall[i][j]); 
							}else if(maze[i][j] == 2){
								coor.x = j * 5;
								coor.z = i * 5;
								maze[i][j] = 0;
							}
						}
					}
				}
				drawBottom();
				makemaze();
				animate();
			}
			function alertContents(){
				console.log(httpRequest.status);
			}
			function animate(){
				var width = window.innerWidth; var height = window.innerHeight;
				var movingTask = function(){
					requestAnimationFrame( animate );
					camera.position.x = coor.x;
					camera.position.z = coor.z;
					var plus_y = 0;
					var now_time = new Date().getTime();
					var delta_time = (now_time - prev_time) / 1000.0;
					prev_time = now_time;
					if(press.up || press.down || press.left || press.right) coor.frame += 1;
					if(jump.jumping){
						var now_time = (now_time - jump.time) / 1000.0;
						if(now_time > 2.0 * Math.PI / 9.8){
							jump.jumping = false;
						}else{       
							plus_y = Math.PI * now_time - 0.5 * gravity * now_time * now_time;
						}
					}
					coor.v_x = 0; coor.v_z = 0;
					if(press.up){
						coor.v_z -= moveScale.move * Math.cos(coor.deg);
						coor.v_x += moveScale.move * Math.sin(coor.deg); 	
					}
					if(press.down){
						coor.v_z += moveScale.move * Math.cos(coor.deg);
						coor.v_x -= moveScale.move * Math.sin(coor.deg);
					}
					if(press.left){
						coor.v_x -= moveScale.move * Math.cos(coor.deg) / 2;
						coor.v_z -= moveScale.move * Math.sin(coor.deg) / 2;
					}
					if(press.right){
						coor.v_x += moveScale.move * Math.cos(coor.deg) / 2;
						coor.v_z += moveScale.move * Math.sin(coor.deg) / 2; 		
					}
					//console.log(delta_time, coor.v_x, coor.v_z);
					var prev_x = coor.x, prev_z = coor.z;
					coor.x += delta_time * coor.v_x; coor.z += delta_time * coor.v_z;
					var rr = Math.floor((coor.z / 5) + 0.5);
					var cc = Math.floor((coor.x / 5) + 0.5);
					//console.log(rr,cc, maze[rr][cc]);
					if(maze[rr][cc] == 1){
						coor.x = prev_x * 1.03 - coor.x * 0.03; coor.z = prev_z * 1.03 - coor.z * 0.03;
					}
					if(moving.doing && maze[rr][cc] === undefined){
						finished = true;
						console.log("SUCCESS!!!!");
						press.left = false; press.right = false; press.up = false; press.down = false;
						moving.doing = false;
						console.log(save_view);
						httpRequest = new XMLHttpRequest();
						httpRequest.onreadystatechange = alertContents;
						httpRequest.open('POST', 'http://52.78.113.241:3000/upload');
						httpRequest.setRequestHeader("Content-type", "application/json");
						httpRequest.send(JSON.stringify({map: maze, record: save_view}));
					}
					//press.up = false; press.down = false; press.left = false; press.right = false;
					var real_y = (y_val - 0.1) + 0.1 * Math.cos(coor.frame / 6.0);
					camera.position.y = real_y + plus_y;
					var xx = coor.x + 100 * Math.sin(coor.deg);
					var yy = (((y_val + real_y * 9) / 10) + plus_y) + 100 * Math.sin(coor.ydeg);
					var zz = coor.z - 100 * Math.cos(coor.deg);
					camera.lookAt(new THREE.Vector3(xx, yy, zz));
					Sphere.position.x = (camera.position.x * 99 + xx) / 100;
					Sphere.position.y = (camera.position.y * 99 + yy) / 100;
					Sphere.position.z = (camera.position.z * 99 + zz) / 100;
					if(moving.doing && save_view.length < max_frame){
						save_view.push({x: camera.position.x, y: camera.position.y, z: camera.position.z, cx: xx, cy: yy, cz: zz});
					}
					if(moving.doing) document.body.style.cursor = "none";
					else document.body.style.cursor = "default";
					if(moving.doing){
						if(cursor_now.x <= 0.02 * width){
							moving.ori_deg -= moveScale.deg * Math.PI / 180.0;
							coor.deg -= moveScale.deg * Math.PI / 180.0;
						}if(cursor_now.x >= 0.98 * width){
							moving.ori_deg += moveScale.deg * Math.PI / 180.0;
							coor.deg += moveScale.deg * Math.PI / 180.0;
						}
					}
				}
				var twoTask = function(){
					var aimCanvas = document.getElementById('aim');
					ctx = aimCanvas.getContext('2d');
					aimCanvas.width = width;
					aimCanvas.height = height;
					ctx.strokeStyle="#FFFFFF";
					ctx.beginPath();
					ctx.moveTo(width/2 - 10, height/2);
					ctx.lineTo(width/2 - 2, height/2);
					ctx.stroke();
					ctx.beginPath();
					ctx.moveTo(width/2 + 10, height/2);
					ctx.lineTo(width/2 + 2, height/2);
					ctx.stroke();
					ctx.beginPath();
					ctx.moveTo(width/2, height/2 - 10);
					ctx.lineTo(width/2, height/2 - 2);
					ctx.stroke();
					ctx.beginPath();
					ctx.moveTo(width/2, height/2 + 10);
					ctx.lineTo(width/2, height/2 + 2);
					ctx.stroke();
					var mapCanvas = document.getElementById('minimap');
					ctxmap = mapCanvas.getContext('2d');
					mapCanvas.width = width;
					mapCanvas.height = height;
					ctxmap.globalAlpha = 0.5;
					if(finished){
						ctxmap.fillStyle = '#777777';
						ctxmap.fillRect(width / 2 -150, height / 2 - 20, 300, 40);
						ctx.font="30px Arial"
						ctx.textAlign = "center"
						ctx.fillText("Congraturations!", width/2, height/2 + 10);
					}else{
						if(!moving.doing || show_minimap){
							ctxmap.fillStyle = '#777777';
							ctxmap.fillRect(width / 2 - 20 * col - 20, height / 2 - 20 * row - 20, 40 * col + 40, 40 * row + 40);
							for(var i=0;i<row;i++){
								for(var j=0;j<col;j++){
									if(maze[i][j] == 1){
										ctxmap.fillStyle = '#000000';
									}else if(maze[i][j] == 0){
										var rr = Math.floor((coor.z / 5) + 0.5);
										var cc = Math.floor((coor.x / 5) + 0.5);
										if(i == rr && j == cc){
											ctxmap.fillStyle = '#FFFF00';
										}else{
											ctxmap.fillStyle = '#FFFFFF';
										}
									}else{
										ctxmap.fillStyle = '#FF0000';
									}
									ctxmap.fillRect(width / 2 - 20 * col + 40 * j + 2, height / 2 - 20 * row + 40 * i + 2, 36, 36);
								}
							}
						}
					}
				}
				movingTask();
				twoTask();
				renderer.render(scene, camera);

			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function onMouseMove(e){
				cursor_now.x = e.clientX;
				cursor_now.y = e.clientY;
				if(moving.doing){
					//console.log(e.clientX, e.clientY);
					var new_x = e.clientX, new_y = e.clientY;
					var width = window.innerWidth; var height = window.innerHeight;
					coor.ydeg = Math.PI * Math.min(0.5, Math.max(-0.5, (moving.ori_y - new_y)/ height));
					coor.deg = moving.ori_deg - Math.PI  * Math.min(0.5, Math.max(-0.5, (moving.ori_x - new_x)/ width));
					//console.log(coor.ydeg);
				}
			}
			function onMouseDown(e){
				if(!moving.doing && !finished){
					moving.doing = true;
					var width = window.innerWidth; var height = window.innerHeight;
					moving.ori_x = 0.5 * width;//e.clientX;
					moving.ori_y = 0.5 * height;
					moving.ori_deg = coor.deg;
				}
			}
			function onKeyDown(e){
				//console.log("keydown", e.keyCode);
				if(moving.doing){
					// Up
					if(e.keyCode == 38 || e.keyCode == 87){
						if(!(press.up)){
							press.up = true;
						}
					}
					// Down
					if(e.keyCode == 40 || e.keyCode == 83){
						if(!(press.down)){ 	
							press.down = true;
						}
					}
					// Left
					if(e.keyCode == 37 || e.keyCode == 65){
						if(!(press.left)){
							press.left = true;
						}
						//coor.deg -= moveScale.deg * Math.PI / 180.0;
					}
					// Right
					if(e.keyCode == 39 || e.keyCode == 68){
						if(!(press.right)){
							press.right = true;
						}
					}
					// Esc
					if(e.keyCode == 27){
						moving.doing = false;
					}
					// Space
					if(e.keyCode == 32){
						if(!jump.jumping){
							jump.jumping = true;
							jump.time = new Date().getTime();
						}
					}
					if(e.keyCode == 70){
						coor.deg += Math.PI;
					}
				}
				if(e.keyCode == 81){
					show_minimap = true;
				}
			}
			function onKeyUp(e){
				//console.log("keyup", e.keyCode);
				if(moving.doing){
					// Up
					if(e.keyCode == 38 || e.keyCode == 87){
						if((press.up)){
							press.up = false;
						}
					}
					// Down
					if(e.keyCode == 40 || e.keyCode == 83){
						if((press.down)){
							press.down = false;
						}
					}
					// Left
					if(e.keyCode == 37 || e.keyCode == 65){
						if((press.left)){
							press.left = false;
						}
						//coor.deg -= moveScale.deg * Math.PI / 180.0;
					}
					// Right
					if(e.keyCode == 39 || e.keyCode == 68){
						if((press.right)){
							press.right = false;
						}
					}
				}
				if(e.keyCode == 81){
					show_minimap = false;
				}
			}
		</script>
	</body>
</html>